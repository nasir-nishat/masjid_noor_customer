import 'dart:async';import 'package:bot_toast/bot_toast.dart';import 'package:flutter/foundation.dart';import 'package:intl/intl.dart';import 'package:masjid_noor_customer/presentation/widgets/loading_widget.dart';import 'package:supabase_flutter/supabase_flutter.dart';import 'package:flutter/material.dart';import 'package:logging/logging.dart' as logger;// BuildContext extensionextension BuildContextHelper on BuildContext {  Future<Result<T>> loading<T>(Future<T> Function() callback) async {    return await UIHelpers.wait<T>(callback);  }}// Future extensionsextension FutureHelpers<T> on Future<T> {  Future<Result<T>> wait() async {    return await UIHelpers.wait<T>(() async => await this);  }}extension FutureOrHelpers<T> on FutureOr<T> {  Future<Result<T>> wait() async {    return await UIHelpers.wait<T>(() async => await this);  }}// Result classesabstract class Result<T> {  final T? data;  final ErrorDetails? error;  bool get isError => error != null;  bool get isSuccess => !isError;  const Result({this.data, this.error});}class ResultSuccess<T> extends Result<T> {  const ResultSuccess(T data) : super(data: data);}class ResultError<T> extends Result<T> {  const ResultError(ErrorDetails error) : super(error: error);}class ErrorDetails {  final String message;  final StackTrace? stackTrace;  final String? statusCode;  const ErrorDetails(this.message, {this.stackTrace, this.statusCode});}// UI Helpersclass UIHelpers {  static final logger.Logger _logger = logger.Logger('UIHelpers');  static CancelFunc showLoading({    bool barrierDismissible = false,    bool showCancelButton = false,  }) {    return BotToast.showCustomLoading(      toastBuilder: (cancelFunc) {        return LoadingWidget(          onClose: kDebugMode || showCancelButton ? cancelFunc : null,        );      },      clickClose: barrierDismissible,      allowClick: false,      backButtonBehavior: BackButtonBehavior.ignore,    );  }  static Future<Result<T>> wait<T>(FutureOr<T> Function() future) async {    final CancelFunc cancel = showLoading();    try {      _logger.info('Operation started');      final T result = await future();      _logger.info('Operation completed successfully');      cancel();      return ResultSuccess(result);    } on AuthException catch (e, st) {      _logger.warning('Authentication error', e, st);      cancel();      return ResultError(ErrorDetails(e.message, stackTrace: st));    } on Exception catch (e, st) {      _logger.warning('Exception occurred', e, st);      cancel();      return ResultError(ErrorDetails(_getExceptionMessage(e), stackTrace: st));    } catch (e, st) {      _logger.severe('Unexpected error', e, st);      cancel();      return ResultError(ErrorDetails(e.toString(), stackTrace: st));    }  }  static String _getExceptionMessage(Exception e) {    final String fullMessage = e.toString();    return fullMessage.startsWith('Exception: ')        ? fullMessage.substring(11)        : fullMessage;  }}// String extensionextension StringExtension on String {  String capitalize() {    return isNotEmpty ? '${this[0].toUpperCase()}${substring(1)}' : this;  }}// TimeOfDay extensionextension TimeOfDayExtension on TimeOfDay {  String format24Hour() {    return '${hour.toString().padLeft(2, '0')}:${minute.toString().padLeft(2, '0')}';  }}extension CurrencyFormatting on double {  String toCurrency({    String locale = 'ko_KR',    String symbol = 'â‚©',    int decimalDigits = 2,  }) {    final NumberFormat currencyFormat = NumberFormat.currency(      locale: locale,      symbol: symbol,      decimalDigits: decimalDigits,    );    return currencyFormat.format(this);  }}