import 'dart:async';import 'package:bot_toast/bot_toast.dart';import 'package:flutter/foundation.dart';import 'package:supabase_flutter/supabase_flutter.dart';import 'package:flutter/material.dart';import '../widgets/loading_widget.dart';extension BuildContextHelper on BuildContext {  Future<Result<T>> loading<T>(Future<T> Function() callback) async {    return await Functions.wait<T>(() async {      return await callback();    });  }}extension FutureHelpers on Future {  Future<Result<T>> wait<T>() async {    return await Functions.wait<T>(() async {      return await this;    });  }}extension FutureOrHelpers on FutureOr {  Future<Result<T>> wait<T>() async {    return await Functions.wait<T>(() async {      return await this;    });  }}abstract class Result<T> {  final T? data;  final ErrorMd? error;  bool get isError => error != null;  bool get isSuccess => !isError;  const Result({this.data, this.error});}class ResultSuccess<T> extends Result<T> {  const ResultSuccess(T data) : super(data: data);}class ResultError<T> extends Result<T> {  const ResultError(ErrorMd error) : super(error: error);}class ErrorMd {  final String message;  final StackTrace? stackTrace;  final String? statusCode;  const ErrorMd(this.message, {this.stackTrace, this.statusCode});}abstract class Functions {  static CancelFunc showLoading(      {bool barrierDismissible = false, bool showCancelButton = false}) {    return BotToast.showCustomLoading(      toastBuilder: (cancelFunc) {        return LoadingWidget(            onClose: kDebugMode                ? cancelFunc                : showCancelButton                    ? cancelFunc                    : null);      },      clickClose: barrierDismissible,      allowClick: false,      backButtonBehavior: BackButtonBehavior.ignore,    );  }  static Future<Result<T>> wait<T>(FutureOr<T> Function() future) async {    CancelFunc cancel = showLoading();    try {      print('loading');      T result = await future();      print('done');      cancel();      return ResultSuccess(result);    } on AuthException catch (e, st) {      cancel();      print("Auth");      print(e);      print("Auth");      return ResultError(ErrorMd(e.message, stackTrace: st));    } on Exception catch (e, st) {      cancel();      print("Exception");      print(e);      print("Exception");      return ResultError(ErrorMd(e.message, stackTrace: st));    } catch (e, st) {      cancel();      print("error");      print(e);      print("error");      return ResultError(ErrorMd(e.toString(), stackTrace: st));    }  }}extension ExceptionExtensions on Exception {  String get message {    if (toString().contains("Exception: ")) {      return toString().replaceAll("Exception: ", "");    }    return toString();  }  static CancelFunc showLoading(      {bool barrierDismissible = false, bool showCancelButton = false}) {    return BotToast.showCustomLoading(      toastBuilder: (cancelFunc) {        return LoadingWidget(            onClose: kDebugMode                ? cancelFunc                : showCancelButton                    ? cancelFunc                    : null);      },      clickClose: barrierDismissible,      allowClick: false,      backButtonBehavior: BackButtonBehavior.ignore,    );  }}extension StringExtension on String {  String toCapitalize() {    return "${this[0].toUpperCase()}${this.substring(1)}";  }}extension TimeOfDayExtension on TimeOfDay {  String format24Hour() {    final hourStr = hour.toString().padLeft(2, '0');    final minuteStr = minute.toString().padLeft(2, '0');    return '$hourStr:$minuteStr';  }}